#include <avr/pgmspace.h>
#include <Tlc5940.h>

/**
 * A couple of tables generated by an external program. Here's that program's source:
 *
#include <stdio.h>
#define _USE_MATH_DEFINES
#include <math.h>

int main(int argc, char *argv[])
{
	for (int i = 0; i < 256; i++) {
		if ((i & 15) == 0)
			printf("\n");
		double x = (double)i / 255.0;
		double y = pow(x, 3.5);
		int value = int(y * 4095.0);
		printf("%4i, ", value);
	}

	printf("\n\n");

	for (int i = 0; i < 256; i++) {
		if ((i & 15) == 0)
			printf("\n");
		double x = (double)i / 256.0 * M_PI * 2.0;
		double y = sin(x);
		int value = int(y * 127.5 + 127.5);
		printf("%3i, ", value);
	}

	printf("\n\n");

	for (int y = 0; y < 16; y++) {
		printf("  { ");
		for (int x = 0; x < 16; x++) {
			double dist = sqrt((double)(x*x + y*y) / 450.0);
			int value = int(dist * 255.0);
			printf("%3i, ", value);
		}
		printf(" },\n");
	}

	getchar();

	return 0;
}
*/

/**
 * Gamma correction -- maps 8bit grayscale values to gamma-corrected 12bit PWM values.
 * My display looks nice with a gamma of 3.5, so that's what's in the table.
 */
PROGMEM word gamma[2][256] = {
{
   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   0,    0,    0,    0,    0,    0,    0,    0,    1,    1,    1,    1,    1,    2,    2,    2,
   2,    3,    3,    3,    4,    4,    5,    5,    6,    6,    7,    8,    8,    9,   10,   11,
  11,   12,   13,   14,   15,   16,   17,   19,   20,   21,   22,   24,   25,   27,   29,   30,
  32,   34,   36,   38,   40,   42,   44,   46,   48,   51,   53,   56,   59,   61,   64,   67,
  70,   73,   77,   80,   84,   87,   91,   94,   98,  102,  106,  111,  115,  119,  124,  129,
 134,  139,  144,  149,  154,  160,  165,  171,  177,  183,  189,  195,  202,  209,  215,  222,
 229,  237,  244,  252,  259,  267,  276,  284,  292,  301,  310,  319,  328,  337,  347,  357,
 366,  377,  387,  397,  408,  419,  430,  442,  453,  465,  477,  489,  502,  514,  527,  540,
 554,  567,  581,  595,  609,  624,  639,  654,  669,  685,  700,  717,  733,  749,  766,  783,
 801,  818,  836,  855,  873,  892,  911,  930,  950,  970,  990, 1011, 1032, 1053, 1074, 1096,
1118, 1140, 1163, 1186, 1210, 1233, 1257, 1282, 1306, 1331, 1357, 1382, 1409, 1435, 1462, 1489,
1516, 1544, 1572, 1601, 1630, 1659, 1689, 1719, 1749, 1780, 1811, 1843, 1875, 1907, 1940, 1973,
2007, 2041, 2075, 2110, 2145, 2181, 2217, 2253, 2290, 2327, 2365, 2403, 2442, 2481, 2521, 2561,
2601, 2642, 2683, 2725, 2767, 2810, 2853, 2897, 2941, 2986, 3031, 3076, 3122, 3169, 3216, 3264,
3312, 3360, 3409, 3459, 3509, 3559, 3611, 3662, 3714, 3767, 3820, 3874, 3928, 3983, 4039, 4095,},

/* alternate gamma table giving a blob-like effect -- black, short gamma ramp, full on */
{
   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   0,    0,    1,    3,    8,   15,   27,   43,   64,   92,  126,  168,  218,  277,  346,  426,
 517,  621,  737,  867, 1011, 1171, 1346, 1538, 1747, 1975, 2222, 2488, 2775, 3083, 3414, 3766,
4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095,
4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095,
4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095,
4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095,
4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095,
4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095,}
};

/**
 * A sine table mapping [0, 255] to [0, 255] with the DC value at 127.5
 */
PROGMEM byte sine[256] = {
127, 130, 133, 136, 139, 143, 146, 149, 152, 155, 158, 161, 164, 167, 170, 173,
176, 179, 182, 184, 187, 190, 193, 195, 198, 200, 203, 205, 208, 210, 213, 215,
217, 219, 221, 224, 226, 228, 229, 231, 233, 235, 236, 238, 239, 241, 242, 244,
245, 246, 247, 248, 249, 250, 251, 251, 252, 253, 253, 254, 254, 254, 254, 254,
255, 254, 254, 254, 254, 254, 253, 253, 252, 251, 251, 250, 249, 248, 247, 246,
245, 244, 242, 241, 239, 238, 236, 235, 233, 231, 229, 228, 226, 224, 221, 219,
217, 215, 213, 210, 208, 205, 203, 200, 198, 195, 193, 190, 187, 184, 182, 179,
176, 173, 170, 167, 164, 161, 158, 155, 152, 149, 146, 143, 139, 136, 133, 130,
127, 124, 121, 118, 115, 111, 108, 105, 102,  99,  96,  93,  90,  87,  84,  81,
 78,  75,  72,  70,  67,  64,  61,  59,  56,  54,  51,  49,  46,  44,  41,  39,
 37,  35,  33,  30,  28,  26,  25,  23,  21,  19,  18,  16,  15,  13,  12,  10,
  9,   8,   7,   6,   5,   4,   3,   3,   2,   1,   1,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   1,   1,   2,   3,   3,   4,   5,   6,   7,   8,
  9,  10,  12,  13,  15,  16,  18,  19,  21,  23,  25,  26,  28,  30,  33,  35,
 37,  39,  41,  44,  46,  49,  51,  54,  56,  59,  61,  64,  67,  70,  72,  75,
 78,  81,  84,  87,  90,  93,  96,  99, 102, 105, 108, 111, 115, 118, 121, 124, };

/**
 * Distance of a x/y coordinate from 0/0, normalized so that the max distance
 * (display diagonal) is 255
 */
PROGMEM byte dist[16][16] = {
  {   0,  12,  24,  36,  48,  60,  72,  84,  96, 108, 120, 132, 144, 156, 168, 180,  },
  {  12,  17,  26,  38,  49,  61,  73,  85,  96, 108, 120, 132, 144, 156, 168, 180,  },
  {  24,  26,  34,  43,  53,  64,  76,  87,  99, 110, 122, 134, 146, 158, 170, 181,  },
  {  36,  38,  43,  51,  60,  70,  80,  91, 102, 114, 125, 137, 148, 160, 172, 183,  },
  {  48,  49,  53,  60,  68,  76,  86,  96, 107, 118, 129, 140, 152, 163, 175, 186,  },
  {  60,  61,  64,  70,  76,  85,  93, 103, 113, 123, 134, 145, 156, 167, 178, 190,  },
  {  72,  73,  76,  80,  86,  93, 102, 110, 120, 130, 140, 150, 161, 172, 183, 194,  },
  {  84,  85,  87,  91,  96, 103, 110, 119, 127, 137, 146, 156, 166, 177, 188, 198,  },
  {  96,  96,  99, 102, 107, 113, 120, 127, 136, 144, 153, 163, 173, 183, 193, 204,  },
  { 108, 108, 110, 114, 118, 123, 130, 137, 144, 153, 161, 170, 180, 190, 200, 210,  },
  { 120, 120, 122, 125, 129, 134, 140, 146, 153, 161, 170, 178, 187, 197, 206, 216,  },
  { 132, 132, 134, 137, 140, 145, 150, 156, 163, 170, 178, 187, 195, 204, 214, 223,  },
  { 144, 144, 146, 148, 152, 156, 161, 166, 173, 180, 187, 195, 204, 212, 221, 230,  },
  { 156, 156, 158, 160, 163, 167, 172, 177, 183, 190, 197, 204, 212, 220, 229, 238,  },
  { 168, 168, 170, 172, 175, 178, 183, 188, 193, 200, 206, 214, 221, 229, 238, 246,  },
  { 180, 180, 181, 183, 186, 190, 194, 198, 204, 210, 216, 223, 230, 238, 246, 255,  } };

typedef byte framebuffer_t[16][16];
framebuffer_t framebuffers[2];
volatile byte currentColumn = 0;
volatile byte currentBuffer = 0;
volatile byte nextBuffer = 0;
volatile byte currentGamma = 0;

/* the input pin of the shift register */
const int SHIFTPIN = 6;

/* the buttons and LEDs on board */
const int BTN1 = 14;
const int LED1 = 15;
const int BTN2 = 16;
const int BTN3 = 17;
const int LED2 = 18;
const int BTN4 = 19;

PROGMEM byte roworder[16] = { 2, 0, 3, 1, 7, 5, 4, 6, 8, 10, 9, 11, 15, 13, 12, 14 };

/**
 * This code piggybacks on top of the TLC library and uses the XLAT signal as clock
 * for the shift registers that scan across columns (which is a pretty natural place
 * as the shift occurs during a BLANK period this way).
 * Every 16 columns, it shifts a one into the start of the register to restart the
 * scanning process.
 */
volatile void xlat_callback()
{
  if (currentColumn == 0) {
    digitalWrite(SHIFTPIN, LOW);
    currentBuffer = nextBuffer;
  } else {
    digitalWrite(SHIFTPIN, HIGH);
  }
  
  for (int i = 0; i < 16; i++)
    Tlc.set(i ^ 1, pgm_read_word(gamma[currentGamma] + framebuffers[currentBuffer][pgm_read_byte(roworder + currentColumn)][i]));
  Tlc.update();

  currentColumn = (currentColumn + 1) & 15;
}

inline framebuffer_t &getNextBuffer()
{
  return framebuffers[currentBuffer ^ 1];
}

void swap()
{
  nextBuffer = currentBuffer ^ 1;
}

void waitForUpdate()
{
  while (currentBuffer != nextBuffer);
}

void setup()
{
  memset(framebuffers, 0, sizeof(framebuffers));
  digitalWrite(BTN1, HIGH);
  digitalWrite(BTN2, HIGH);
  digitalWrite(BTN3, HIGH);
  digitalWrite(BTN4, HIGH);
  digitalWrite(LED1, LOW);
  digitalWrite(LED2, LOW);
  digitalWrite(SHIFTPIN, HIGH);
  pinMode(BTN1, INPUT);
  pinMode(BTN2, INPUT);
  pinMode(BTN3, INPUT);
  pinMode(BTN4, INPUT);
  pinMode(LED1, OUTPUT);
  pinMode(LED2, OUTPUT);
  pinMode(SHIFTPIN, OUTPUT);
  Tlc.init();
  Tlc.setAllDC(0x1F);
  tlc_onUpdateFinished = xlat_callback;
  xlat_callback();
}

word frame = 0;

/* A couple of helper defines for reading out the tables */
#define sin(x) pgm_read_byte(sine + ((x) & 255))
#define cos(x) sin((x) + 128)
#define distance_tl(x, y) pgm_read_byte(&dist[x][y])
#define mid2tl(x) (((((x) < 8) ? (7 - (x)) : ((x) - 8)) << 1) + 1)
#define distance_mid(x, y) distance_tl(mid2tl(x), mid2tl(y))

int effectmask = 15;

/**
 * This loop implements a nice plasma effect by overlaying four sine functions --
 * one in the x direction, one in the y direction and two radial ones with different midpoints.
 */
void loop()
{
  const byte bitcount[16] = { 0, 0, 0, 1, 0, 1, 1, 2, 0, 1, 1, 2, 1, 2, 2, 2 };
  
  framebuffer_t &fb = getNextBuffer();
//  digitalWrite(LED2, HIGH);
  for (byte y = 0; y < 16; y++)
    for (byte x = 0; x < 16; x++) {
      word accu = 0;
      if (effectmask & 1)
        accu += sin(((distance_tl(x, y) * 3) >> 1) - ((frame * 17) >> 3));
      if (effectmask & 2)
        accu += sin((x * 11) + (frame >> 1) + ((sin(frame >> 1) - 64) * 2) + ((sin((frame * 7) >> 2) * 5) >> 3));
      if (effectmask & 4)
        accu += sin(y * 17 + frame * 2 + sin(frame) - 128);
      if (effectmask & 8)
        accu += sin((distance_mid(x, y)) + ((frame * 7) >> 2));
      
      fb[x][y] = accu >> bitcount[effectmask];
    }
//  digitalWrite(LED2, LOW);
  swap();
  frame++;
  waitForUpdate();

//  digitalWrite(LED1, frame & 1);

  {  
    /* Switch between low and high contrast */
    static int curButton = HIGH, lastButton = HIGH;
    curButton = digitalRead(BTN1);
    if (curButton != lastButton) {
      if (curButton == LOW) /* button pulls to GND */
        currentGamma ^= 1;
      lastButton = curButton;
    }
  }
  {
    /* Switch between low and high brightness */
    static int brightness = 1;
    static int curButton = HIGH, lastButton = HIGH;
    curButton = digitalRead(BTN3);
    if (curButton != lastButton) {
      if (curButton == LOW) { /* button pulls to GND */
        brightness++;
        brightness &= 3;
        Tlc.setAllDC(0x0F + (brightness << 4));
        xlat_callback();
      }
      lastButton = curButton;
    }
  }
  {
    /* Cycle effects */
    static int curButton = HIGH, lastButton = HIGH;
    curButton = digitalRead(BTN2);
    if (curButton != lastButton) {
      if (curButton == LOW) /* button pulls to GND */
        effectmask++;
      if (effectmask > 15)
        effectmask = 1;
      lastButton = curButton;
    }
  }
}

